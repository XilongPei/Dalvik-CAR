							             Hints的含义
										 

先看一个简化的模型：
假设我们遇到这样的一个car function: func(int, double)，则参数在内存中的分布如下图所示：

|----------|
|\\\\\\\\\\|<-- 为简单起见，假设这个32-bit的内存空间地址是0x00000000，放的是int
|----------|
|          |<-- 这个单元的地址是0x00000004，放的是pad
|----------|
|\\\\\\\\\\|<-- 这个单元的地址是0x00000008，它和下一个单元一起，放的是double(64-bit)，之所以没有从地址0x00000004
|----------|    开始放，是因为eabi标准规定，64-bit的参数必须64-bit对齐，也就是8-byte对齐。
|\\\\\\\\\\|
|----------|
|          |
|----------|


注意，图中每一格代表4-bytes。
然后，我们按照上图计算hint的值：
第一个单元(32-bit)放的不是pad，则hint的bit-0是0；
第二个单元是pad，则hint的bit-1是1；
第三，第四个单元都不是pad，则hint的bit-2,3都是00；
最后，hint=0010（二进制）。




以上是简化的模型，实际上，eabi规定前几个参数要放到寄存器r1, r2, r3里面去（r0放this指针，不考虑），由于每个寄存器都是
32-bit宽的，所以可以将每个寄存器看成栈的一个单元（32-bit的单元，不是普通的byte）。由于eabi规定，64-bit参数不能放到
{r1, r2}，而可以放到{r2, r3}，也就是说，eabi规范将r1, r3看成非64-bit对齐的内存单元，而将r2看成64-bit对齐的内存单元。

好了，将r1, r2, r3考虑进去之后，为了演示在寄存器填pad的情况，我们不是继续使用以上的例子，而是换个例子：
car function: func(int, int, double)，参数的摆放如下图：

|----------|
|\\\\\\\\\\|<-- 这个是r1，（我故意画的像栈，是希望你把它也看成栈），放的是int，int不需要64-bit对齐
|----------|
|\\\\\\\\\\|<-- 这个是r2，放的是第二个int
|----------|
|          |<-- 这个是r3，double不能从这儿开始放，这是eabi规范规定的
|----------|


|----------|
|\\\\\\\\\\|<-- 假设这是一个64-bit对齐的地址(n)，放double的低32-bit
|----------|
|\\\\\\\\\\|<-- 地址(n+4)放的是double的高32-bit
|----------|
|          |
|----------|

然后，我们计算一下hint的值:
第1个32-bit单元(r1)放的不是pad，所以hint的bit-0是0;
第2个32-bit单元(r2)放的不是pad，所以hint的bit-1是0;
第3个32-bit单元(r3)放的是pad，所以hint的bit-2是1;
第4个32-bit单元放的不是pad，所以hint的bit-3是0;
第5个32-bit单元放的不是pad，所以hint的bit-4是0;
最后,hint=00100（二进制）。


由于hint的长度是24-bit，所以最多只能表示24个单元（32-bit）的填充情况。如果参数放到这些单元，并考虑对齐后，超过24个
单元，则我们就不能根据hint来摆放参数了，只能走slow path，就是通过扫描singnature决定参数如何摆放。

